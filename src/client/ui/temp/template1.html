<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <!-- <meta http-equiv="Content-Security-Policy" content="default-src *; script-src * "> -->
  <link rel="stylesheet" href="./fonts/fa/css/all.min.css"/>
  <title>duneTest</title>
</head>
<body>
<div class="dunebody">
  <input type="hidden" name="disable-main" value=""/>
  <main id="stuff">
    <a href="window.alert('hi')"><img src="./assets/tokens.png"/></a>
  </main>
</div>
</body>

<script src="../TemplateEngine.mjs"></script>
<script src="../templates_dune.mjs"></script>
<script defer>

  const dragElement = (dragTarget, dragHandle, options={}) => {

    const target = typeof(dragTarget) === 'object' && dragTarget.tagName  ? dragTarget : document.querySelector(dragTarget),
      handle = dragHandle ? typeof(dragHandle) === 'object' && dragHandle.tagName ? dragHandle : document.querySelector(dragHandle) : target;

    let dragOptions = {
        bound: options.bound ?? true, // set to false to disable binding the draggabale element to the container
        boundingElement: options.boundingElement||document.documentElement,
        mouseButtons: options.mouseButtons||[1,2,3] // mouse buttons to allow for drag
    }
    let posXi = 0, posXf = 0, posYi = 0, posYf = 0;
    let minX, minY, maxX, maxY;
    let boundWidth, boundHeight;
    let finalLTRB = [null,null,null,null]; // left, top, right, bottom

    const getBounds = () => {
        boundWidth = dragOptions.boundingElement.clientWidth;
        boundHeight = dragOptions.boundingElement.clientHeight;        
        minX = 0, minY = 0, maxX = boundWidth - target.offsetWidth, maxY = boundHeight - target.offsetHeight;
        // console.info(minX, minY, maxX, maxY);
    }

    const elementGrab = (ev) => {
        ev.preventDefault();
        if (dragOptions.bound) getBounds();
        posXi = ev.clientX;
        posYi = ev.clientY;
        document.addEventListener('mouseup', elementRelease);
        document.addEventListener('mousemove', elementDrag);
    }

    const elementDrag = (ev) => {
        ev.preventDefault();
        target.dataset.dragging = true;
        posXf = posXi - ev.clientX;
        posYf = posYi - ev.clientY;
        posXi = ev.clientX;
        posYi = ev.clientY;

        finalLTRB[0] = dragOptions.bound ? Math.min(Math.max((target.offsetLeft - posXf), minX), maxX) : target.offsetLeft - posXf;
        finalLTRB[1] = dragOptions.bound ? Math.min(Math.max((target.offsetTop - posYf), minY), maxY) : target.offsetTop - posYf;
        Object.assign(target.style, { left: `${finalLTRB[0]}px`, top: `${finalLTRB[1]}px` });
    }

    const elementRelease = () => {
      document.removeEventListener('mousemove', elementDrag);
      document.removeEventListener('mouseup', elementRelease);
      setTimeout(() => {
        target.dataset.dragging = false;
      }, 500);
    }

    handle.addEventListener('mousedown', (ev) => {if (dragOptions.mouseButtons.includes(ev.which)) elementGrab(ev)});
  }

  const resolveSelector = (targetElementOrSelector) => {
  return typeof(targetElementOrSelector) === 'object' && targetElementOrSelector.tagName ? targetElementOrSelector
  : typeof(targetElementOrSelector) === 'string' ? document.querySelector(targetElementOrSelector)
  : null;
}

const getSiblingZindices = (targetElement, siblingFilter = '.fc-dune') => {
  const parent = typeof(targetElement) === 'object' && targetElement.tagName ? targetElement.parentNode
    : typeof(targetElement) === 'string' ? document.querySelector(targetElement)?.parentNode
    : null;
  if (!parent) {
    console.warn(`Invalid target element:`, targetElement);
    return [];
  }
  const siblings = siblingFilter ? parent.querySelectorAll(siblingFilter)
    : parent.childNodes || [];
  return Array.from(siblings).map(el => {
    const style = window.getComputedStyle(el);
    return parseInt(style.getPropertyValue('z-index')) || 0;
  });
}

const bringToFront = (targetElement) => {
  const target = resolveSelector(targetElement);
  if (!target) return console.warn(`No target element found for selector "${targetElement}"`);
  const zArray = getSiblingZindices(target);
  target.style['z-index'] = (Math.max(...zArray) || 0) + 1;
}

// document.querySelectorAll('div.testclass').forEach(el => {
//   dragElement(el, el.querySelector('header'));
//   el.addEventListener('mousedown', () => bringToFront(el));
// });

const TE = new TemplateEngine(templates);

const setInitialPosition = (modal, container) => {
  const modalSize = { x: modal.offsetWidth/2, y: modal.offsetHeight/2 },
    containerCenter = { x: container.offsetWidth/2, y: container.offsetHeight/2 },
    numberOfModals = container.querySelectorAll('.fc-dune')?.length ?? 0,
    offsetPixels = 10;
  const pos = { x: Math.round(containerCenter.x - modalSize.x + numberOfModals*offsetPixels), y: Math.round(containerCenter.y - modalSize.y + numberOfModals*offsetPixels) }
  modal.style.left = `${pos.x}px`;
  modal.style.top = `${pos.y}px`;
}

// Goes in FrameController
const insertModal = (frameData={}, container = '.dunebody') => {
  const frame = TE.create(frameData),
    target = container?.tagName ? container : document.querySelector(container) ?? document.body;
  target.append(frame);
  setInitialPosition(frame, target);
  frame.classList.remove('hide');
  dragElement(frame, frame.querySelector('header'));
  frame.addEventListener('mousedown', () => bringToFront(frame));
  return frame.id;
}

// createModal({
  // type: string - loading, error, alert, prompt,
  // awaitInput: boolean,
  // awaitEvent: string,
  // eventTimeout: milliseconds
  // container: name of preset container in frame controller
  // disableMain: boolean - disable screen while modal is active (default false)
  // blurMain: boolean - blur screen while modal is active (default true, only active with disable=true)
  // hidden: boolean - whether to keep modal hidden after appending (default false)
  // draggable: boolean - default true
  // otherProps: all other modal properties
// })

const destroyModal = (modalId) => {
  console.log(`Destroying ${modalId}`);
  document.querySelector(`#${modalId}`).remove();
}

const createModal = async (modalData={}) => {
  const container = modalData.container || '.dunebody',
    modalType = modalData.type ?? 'custom';
  if (presets[modalType] || modalType === 'custom') {
    const frameData = presets[modalType] ?? {},
      targetContainer = container.tagName ? container : document.querySelector(container);
    if (!targetContainer) return console.warn('Could not locate container.');
    Object.assign(frameData, modalData);   
    const frameId = insertModal(frameData, targetContainer);
    // Blocking modal awaits for return data
    if (modalData.awaitInput) {
      return new Promise(res => {
        const returnDataHandler = (ev) => {
          if (ev.detail.id === frameId) {
            console.log(`correct id found`);
            res(ev.detail);
            targetContainer.removeEventListener('returnModalData', returnDataHandler);
          }
        }
        targetContainer.addEventListener('returnModalData', returnDataHandler);
      });
    }
    else if (modalData.awaitEvent) {
      console.log(`Creating event: ${modalData.awaitEvent}`);
      const loadingEventHandler = () => {
        destroyModal(frameId);
        targetContainer.removeEventListener(modalData.awaitEvent, loadingEventHandler);
      }
      targetContainer.addEventListener(modalData.awaitEvent, loadingEventHandler);
      const timer = parseInt(modalData.eventTimeout) || 5000;
      setTimeout(() => targetContainer.dispatchEvent(new CustomEvent(modalData.awaitEvent)), timer);
    }
    else return frameId;
  }
  else console.warn(`Bad modal type: ${modalType}`);
}

</script>
</html>